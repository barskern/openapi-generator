use crate::headers::*;
use std::io;
use std::marker::PhantomData;
use std::future::Future;
use std::pin::Pin;
use std::default::Default;
use futures::FutureExt;
use headers::{ContentType, HeaderMapExt};
use hyper;
use hyper::{Request, Response, Error, StatusCode};
use url::form_urlencoded;
use openapi_context::auth::{Authorization, AuthData, Scopes};
use openapi_context::{Has, Pop, Push, XSpanIdString};
use crate::Api;

pub struct NewAddContext<T, A>
{
    inner: T,
    marker: PhantomData<A>,
}

impl<T, A, B, C, D> NewAddContext<T, A>
    where
        A: Default + Push<XSpanIdString, Result=B>,
        B: Push<Option<AuthData>, Result=C>,
        C: Push<Option<Authorization>, Result=D>,
        T: hyper::service::Service<(Request<hyper::Body>, D), Response = Response<hyper::Body>, Error = Error> + 'static,
{
    pub fn new(inner: T) -> NewAddContext<T, A> {
        NewAddContext {
            inner,
            marker: PhantomData,
        }
    }
}

impl<T, A, B, C, D> hyper::service::Service<NewAddContext<T, A>> for NewAddContext<T, A>
    where
        A: Default + Push<XSpanIdString, Result=B>,
        B: Push<Option<AuthData>, Result=C>,
        C: Push<Option<Authorization>, Result=D>,
        T: hyper::service::Service<(Request<hyper::Body>, D), Response = Response<hyper::Body>, Error = Error> + 'static,
{
    type Response = Self;
    type Error = Error;
    type Future = futures::future::Ready<Result<Self::Response, Self::Error>>;

    fn poll_ready(&mut self, cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        std::task::Poll::Ready(Ok(()))
    }

    fn call(&mut self, target: NewAddContext<T, A>) -> Self::Future {
        futures::future::ready(self.inner.new_service().map(|s| AddContext::new(s)))
    }
}

/// Middleware to extract authentication data from request
pub struct AddContext<T, A>
{
    inner: T,
    marker: PhantomData<A>,
}

impl<T, A, B, C, D> AddContext<T, A>
    where
        A: Default + Push<XSpanIdString, Result=B>,
        B: Push<Option<AuthData>, Result=C>,
        C: Push<Option<Authorization>, Result=D>,
        T: hyper::service::Service<(Request<hyper::Body>, D), Response = Response<hyper::Body>, Error = Error>,
{
    pub fn new(inner: T) -> AddContext<T, A> {
        AddContext {
            inner,
            marker: PhantomData,
        }
    }
}

impl<T, A, B, C, D> hyper::service::Service<Request<hyper::Body>> for AddContext<T, A>
    where
        A: Default + Push<XSpanIdString, Result=B>,
        B: Push<Option<AuthData>, Result=C>,
        C: Push<Option<Authorization>, Result=D>,
        T: hyper::service::Service<(Request<hyper::Body>, D), Response = Response<hyper::Body>, Error = Error>,
{
    type Response = Response<hyper::Body>;
    type Error = Error;
    type Future = T::Future;

    fn poll_ready(&mut self, cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        std::task::Poll::Ready(Ok(()))
    }

    fn call(&self, req: Request<hyper::Body>) -> Self::Future {
        let context = A::default().push(XSpanIdString::get_or_generate(&req));

        {{#authMethods}}
        {{#isBasic}}
        {
            use headers::Authorization as HyperAuth;
            use headers::authorization::Basic;
            use std::ops::Deref;
            if let Some(basic) = req.headers().get_typed::<HyperAuth<Basic>>().cloned() {
                let auth_data = AuthData::Basic(basic.deref().clone());
                let context = context.push(Some(auth_data));
                let context = context.push(None::<Authorization>);
                return self.inner.call((req, context));
            }
        }
        {{/isBasic}}
        {{#isOAuth}}
        {
            use headers::Authorization as HyperAuth;
            use headers::authorization::Bearer;
            use std::ops::Deref;
            if let Some(bearer) = req.headers().get_typed::<HyperAuth<Bearer>>().cloned() {
                let auth_data = AuthData::Bearer(bearer.deref().clone());
                let context = context.push(Some(auth_data));
                let context = context.push(None::<Authorization>);
                return self.inner.call((req, context));
            }
        }
        {{/isOAuth}}
        {{#isApiKey}}
        {{#isKeyInHeader}}
        {
            if let Some(header) = req.headers().get_typed::<ApiKey{{-index}}>().cloned() {
                let auth_data = AuthData::ApiKey(header.0);
                let context = context.push(Some(auth_data));
                let context = context.push(None::<Authorization>);
                return self.inner.call((req, context));
            }
        }
        {{/isKeyInHeader}}
        {{#isKeyInQuery}}
        {
            let key = form_urlencoded::parse(req.query().unwrap_or_default().as_bytes())
                .filter(|e| e.0 == "api_key_query")
                .map(|e| e.1.clone().into_owned())
                .nth(0);
            if let Some(key) = key {
                let auth_data = AuthData::ApiKey(key);
                let context = context.push(Some(auth_data));
                let context = context.push(None::<Authorization>);
                return self.inner.call((req, context));
            }
        }
        {{/isKeyInQuery}}
        {{/isApiKey}}
        {{/authMethods}}

        let context = context.push(None::<AuthData>);
        let context = context.push(None::<Authorization>);
        return self.inner.call((req, context));
    }
}
